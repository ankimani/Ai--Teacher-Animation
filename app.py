import os
import json
import time
import shutil
import subprocess
import textwrap
from flask import Flask, request, render_template, jsonify
from dotenv import load_dotenv
from openai import OpenAI
from textwrap import wrap
import threading
import asyncio
# Load environment variables
load_dotenv()
app = Flask(__name__)

# Initialize OpenAI client
openai_client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# Clean up previous animation files
def cleanup_old_files():
    partial_movie_dir = "media/videos/manim_script/480p15/partial_movie_files"
    if os.path.exists(partial_movie_dir):
        shutil.rmtree(partial_movie_dir, ignore_errors=True)
        time.sleep(2)

def generate_explanation(topic):
    try:
        response = openai_client.chat.completions.create(
            model="gpt-4",
            messages=[
                {
                    "role": "user",
                    "content": f"Explain {topic} in a concise way under 1 minute. "
                               "Use stepwise explanations only where necessary (e.g., systematic processes). "
                               "Avoid unnecessary steps for definitions (e.g., 'Define Force'). "
                               "Keep explanations under 80 words for clarity."
                }
            ]
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        print("\u274c OpenAI API Error:", str(e))
        return None

def generate_animation(topic, explanation):
    try:
        cleanup_old_files()
        explanation_steps = explanation.split(". ")  # Split explanation into steps
        safe_topic = json.dumps(topic)

        wrapped_steps = []
        SCREEN_WIDTH = 40  # Increased width for better text wrapping

        # Determine if explanation requires steps
        if "Step 1:" in explanation or "Step 2:" in explanation:
            for i, step in enumerate(explanation_steps, start=1):
                words = step.split()
                if not words:
                    continue  # Skip empty steps
                
                step_lines = [f"Step {i}:"]  # Step header
                wrapped_text = wrap(step, width=SCREEN_WIDTH)  # Wrap text to screen width
                step_lines.extend(wrapped_text)  # Append wrapped lines
                
                wrapped_steps.append("\n".join(step_lines))  # Join as a single string for Manim
        else:
            wrapped_steps = [explanation]  # No steps, just display the explanation directly

        # Generate Manim script
        script = f"""
from manim import *

class AutoGeneratedScene(Scene):
    def construct(self):
        title = Text({safe_topic}, font_size=32).move_to(UP * 2)
        self.play(FadeIn(title))
        self.wait(2)
        self.play(FadeOut(title))

        # Explanation steps or direct text
        steps = {json.dumps(wrapped_steps)}
        text_objects = VGroup()  # Grouping for proper alignment

        for step in steps:
            step_text = Paragraph(
                step,
                font_size=76, 
                line_spacing=1.4,
                alignment="center"
            ).scale(0.9)

            step_text.set_width(config.frame_width * 0.85)  # Ensures margin from edges
            step_text.move_to(ORIGIN)  # Centers text perfectly

            text_objects.add(step_text)

            self.play(Write(step_text))
            self.wait(4)  # Extended wait time for readability
            self.play(FadeOut(step_text))
            self.wait(1)

        # Thank you message
        thank_you = Text("Thank you", font_size=30).move_to(DOWN * 2)
        self.play(FadeIn(thank_you))
        self.wait(2)
        self.play(FadeOut(thank_you))
"""
        with open("manim_script.py", "w", encoding="utf-8") as file:
            file.write(script)

        process = subprocess.Popen(["manim", "-pql", "manim_script.py", "AutoGeneratedScene"], shell=True)
        process.wait()

        animation_path = "media/videos/manim_script/480p15/AutoGeneratedScene.mp4"
        return animation_path if os.path.exists(animation_path) else None
    except Exception as e:
        print("\u274c Manim Error:", str(e))
        return None
# Flask Routes
@app.route("/")
def home():
    return render_template("index.html")

@app.route("/explain", methods=["POST"])
def explain():
    data = request.get_json()
    topic = data.get("topic", "").strip()
    if not topic:
        return jsonify({"error": "Topic is required"}), 400

    explanation = generate_explanation(topic)
    if not explanation:
        return jsonify({"error": "Failed to generate explanation"}), 500

    # Use asyncio to wait for the animation to complete
    async def generate_and_wait():
        animation_path = await asyncio.to_thread(generate_animation, topic, explanation)
        return animation_path

    animation_path = asyncio.run(generate_and_wait())

    if not animation_path:
        return jsonify({"error": "Failed to generate animation"}), 500

    return jsonify({"explanation": explanation, "video": animation_path})

if __name__ == "__main__":
    app.run(debug=True)